# Case recovery: Step 2

## Changed Files
- index.css

## Asset Files
- Bundle: bundle.js
- Manifest: main.LAST_HASH.hot-update.json, size: 28
- Update: main.hot-update.js, size: 8241

## Manifest

### main.LAST_HASH.hot-update.json

```json
{"c":["main"],"r":[],"m":[]}
```


## Update


### main.hot-update.js

#### Changed Modules
- ../../../../../rspack/dist/cssExtractHmr.js
- ./index.css

#### Changed Runtime Modules
- webpack/runtime/define_property_getters
- webpack/runtime/get_full_hash
- webpack/runtime/has_own_property
- webpack/runtime/make_namespace_object

#### Changed Content
```js
"use strict";
self["webpackHotUpdate"]('main', {
"../../../../../rspack/dist/cssExtractHmr.js": (function (__unused_webpack_module, exports) {

// The require scope
var __nested_webpack_require_39_58__ = {};
/************************************************************************/ // webpack/runtime/define_property_getters
(()=>{
    __nested_webpack_require_39_58__.d = function(exports1, definition) {
        for(var key in definition)if (__nested_webpack_require_39_58__.o(definition, key) && !__nested_webpack_require_39_58__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
// webpack/runtime/has_own_property
(()=>{
    __nested_webpack_require_39_58__.o = function(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };
})();
// webpack/runtime/make_namespace_object
(()=>{
    // define __esModule on exports
    __nested_webpack_require_39_58__.r = function(exports1) {
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
/************************************************************************/ var __nested_webpack_exports__ = {};
__nested_webpack_require_39_58__.r(__nested_webpack_exports__);
__nested_webpack_require_39_58__.d(__nested_webpack_exports__, {
    cssReload: function() {
        return cssReload;
    },
    normalizeUrl: function() {
        return normalizeUrl;
    }
});
function normalizeUrl(url) {
    const urlString = url.trim();
    if (/^data:/i.test(urlString)) return urlString;
    const protocol = -1 !== urlString.indexOf("//") ? `${urlString.split("//")[0]}//` : "";
    const components = urlString.replace(new RegExp(protocol, "i"), "").split("/");
    const host = components[0].toLowerCase().replace(/\.$/, "");
    components[0] = "";
    const path = components.reduce((accumulator, item)=>{
        switch(item){
            case "..":
                accumulator.pop();
                break;
            case ".":
                break;
            default:
                accumulator.push(item);
        }
        return accumulator;
    }, []).join("/");
    return protocol + host + path;
}
const srcByModuleId = Object.create(null);
const noDocument = "undefined" == typeof document;
const { forEach } = Array.prototype;
function debounce(fn, time) {
    let timeout = 0;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        const self = this;
        const functionCall = function() {
            return fn.apply(self, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(functionCall, time);
    };
}
function noop() {}
function getCurrentScriptUrl(moduleId) {
    let src = srcByModuleId[moduleId];
    if (!src) {
        if (document.currentScript) ({ src } = document.currentScript);
        else {
            const scripts = document.getElementsByTagName("script");
            const lastScriptTag = scripts[scripts.length - 1];
            if (lastScriptTag) ({ src } = lastScriptTag);
        }
        srcByModuleId[moduleId] = src;
    }
    return (fileMap)=>{
        if (!src) return null;
        const splitResult = src.match(/([^\\/]+)\.js$/);
        // biome-ignore lint/complexity/useOptionalChain: not use optionalChain to support legacy browser
        const filename = splitResult && splitResult[1];
        if (!filename || !fileMap) return [
            src.replace(".js", ".css")
        ];
        return fileMap.split(",").map((mapRule)=>{
            const reg = new RegExp(`${filename}\\.js$`, "g");
            return normalizeUrl(src.replace(reg, `${mapRule.replace(/{fileName}/g, filename)}.css`));
        });
    };
}
function updateCss(el, url) {
    let normalizedUrl;
    if (url) normalizedUrl = url;
    else {
        if (!el.href) return;
        normalizedUrl = el.href.split("?")[0];
    }
    if (!isUrlRequest(normalizedUrl)) return;
    if (false === el.isLoaded) // We seem to be about to replace a css link that hasn't loaded yet.
    // We're probably changing the same file more than once.
    return;
    if (!normalizedUrl || !(normalizedUrl.indexOf(".css") > -1)) return;
    el.visited = true;
    const newEl = el.cloneNode();
    newEl.isLoaded = false;
    newEl.addEventListener("load", ()=>{
        if (newEl.isLoaded) return;
        newEl.isLoaded = true;
        if (el.parentNode) el.parentNode.removeChild(el);
    });
    newEl.addEventListener("error", ()=>{
        if (newEl.isLoaded) return;
        newEl.isLoaded = true;
        if (el.parentNode) el.parentNode.removeChild(el);
    });
    newEl.href = `${normalizedUrl}?${Date.now()}`;
    const parent = el.parentNode;
    if (!parent) return;
    if (el.nextSibling) parent.insertBefore(newEl, el.nextSibling);
    else parent.appendChild(newEl);
}
function getReloadUrl(href, src) {
    let ret = "";
    const normalizedHref = normalizeUrl(href);
    src.some((url)=>{
        if (normalizedHref.indexOf(src) > -1) ret = url;
    });
    return ret;
}
function reloadStyle(src) {
    if (!src) return false;
    const elements = document.querySelectorAll("link");
    let loaded = false;
    forEach.call(elements, (el)=>{
        if (!el.href) return;
        const url = getReloadUrl(el.href, src);
        if (!isUrlRequest(url)) return;
        if (true === el.visited) return;
        if (url) {
            updateCss(el, url);
            loaded = true;
        }
    });
    return loaded;
}
function reloadAll() {
    const elements = document.querySelectorAll("link");
    forEach.call(elements, (el)=>{
        if (true === el.visited) return;
        updateCss(el);
    });
}
function isUrlRequest(url) {
    // An URL is not an request if
    // It is not http or https
    if (!/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url)) return false;
    return true;
}
function cssReload(moduleId, options) {
    if (noDocument) {
        console.log("[HMR] No `window.document` found, CSS HMR disabled");
        return noop;
    }
    const getScriptSrc = getCurrentScriptUrl(moduleId);
    function update() {
        const src = getScriptSrc(options.filename);
        const reloaded = reloadStyle(src);
        if (options.locals) {
            console.log("[HMR] Detected local CSS Modules. Reload all CSS");
            reloadAll();
            return;
        }
        if (reloaded) // biome-ignore lint/complexity/useOptionalChain: not use optionalChain to support legacy browser
        console.log("[HMR] CSS reload %s", src && src.join(" "));
        else {
            console.log("[HMR] Reload all CSS");
            reloadAll();
        }
    }
    return debounce(update, 50);
}
var __webpack_export_target__ = exports;
for(var i in __nested_webpack_exports__)__webpack_export_target__[i] = __nested_webpack_exports__[i];
if (__nested_webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, '__esModule', {
    value: true
});

0 && 0;

}),
"./index.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        var cssReload = (__webpack_require__(/*! ../../../../../rspack/dist/cssExtractHmr.js */ "../../../../../rspack/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = function () {
	return "CURRENT_HASH";
};

})();

}
);
```